<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>McTT: Building A Correct-By-Construction Proof Checkers For
Type Theories</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="styling.css" />
  <script type="text/javascript" src="style.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script>
   $(function () {
       $("pre>code").parents("pre").each(function(_) {
           var pre = this;
           for (c of pre.children) {
               c.classList.add(pre.className);
           }
       })
   })

   $(function() {
       var h1elem = $("h1")[0];
       h1elem.classList.add("project_title");
       var header = $(`<div id="header_wrap" class="outer">
          <header class="inner">
            
              <a id="forkme_banner" href="https://github.com/Beluga-lang/McTT">Fork on GitHub</a>
            ${h1elem.outerHTML}
          </header>
      </div>`);
       var body = h1elem.parentNode;
       h1elem.remove();
       var sec = document.createElement("section");
       sec.classList.add("inner");
       sec.innerHTML = body.innerHTML;
       body.innerHTML = '';
       body.appendChild(header[0]);
       body.appendChild(sec);
   })
  </script>
  <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h1
id="mctt-building-a-correct-by-construction-proof-checkers-for-type-theories">McTT:
Building A Correct-By-Construction Proof Checkers For Type Theories</h1>
<p>McTT is a verified, runnable typechecker for Martin-Löf type theory.
This project provides an executable, to which we can feed a program in
Martin-Löf type theory to check whether this program has the specified
type. McTT is novel in that it is implemented and verified in Coq. More
specifically, we proved that the typechecking algorithm extracted from
Coq is sound and complete: a program passes typechecker if and only if
it is a well-typed program in MLTT. This is the first verified proof
assistant (despite being elementary) and serves as a basis for future
extensions.</p>
<h2 id="online-documentation">Online Documentation</h2>
<p>We have generated a <a href="dep.html">Coqdoc</a> for browsing our
Coq proof.</p>
<h2 id="architecture">Architecture</h2>
<p>McTT has the following architecture:</p>
<pre><code>    | source code of McTT
    v
+-------+
| lexer |          OCaml code generated by ocamllex
+-------+
    | stream of tokens
    v
+--------+
| parser |         Coq code generated by Menhir
+--------+
    | concrete syntax tree
    v
+------------+
| elaborator |     Coq code
+------------+
    | abstract syntax tree
    v
+-------------+
| typechecker |    Coq code
| (normalizer |
|   included) |
+-------------+
    | yes or no    Driver in OCaml
    v</code></pre>
<p>In this architecture, most code is in Coq, with accompanying theorems
to justify the implementation.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><a href="https://ocaml.org/">OCaml</a> 4.14.2</li>
<li><a href="http://cambium.inria.fr/~fpottier/menhir/">Menhir</a></li>
<li><a
href="https://gitlab.inria.fr/fpottier/menhir/-/tree/master/coq-menhirlib">Coq-Menhirlib</a></li>
<li><a href="https://coq.inria.fr/">Coq</a> 8.20.0</li>
<li><a
href="https://github.com/mattam82/Coq-Equations">Coq-Equations</a>
1.3</li>
</ul>
<p>We recommend to install dependencies in the following way:</p>
<pre class="bash"><code>opam update
opam switch create coq-8.20.0 4.14.2
opam pin add coq 8.20.0
opam repo add coq-released https://coq.inria.fr/opam/released
opam install -y menhir coq-equations coq-menhirlib ppx_inline_test ppx_expect</code></pre>
<h2 id="development">Development</h2>
<p>Use the toplevel <code>make</code> to build the whole project:</p>
<pre><code>make</code></pre>
<p>Makefile will try to find out the number of your CPU cores and
parallel as much as possible.</p>
<p>Once <code>make</code> finishes, you can run the binary:</p>
<pre><code>dune exec mctt examples/nary.mctt # or your own example</code></pre>
<p>or more directly</p>
<pre><code>_build/default/driver/mctt.exe examples/nary.mctt # or your own example</code></pre>
<p>To build Coq proof only, you can go into and only build the
<code>theories</code> directory:</p>
<pre><code>cd theories
make</code></pre>
<h2 id="external-syntax">External Syntax</h2>
<p>Our interpreter accepts a <code>prog</code>, defined in the following
grammar (written in <a
href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>):</p>
<pre class="EBNF"><code>prog = term , &#39;:&#39; , type;

type = term;
     (* function type *)
term = &#39;forall&#39; , {parameter} , &#39;-&gt;&#39; , term
     (* function *)
     | &#39;fun&#39; , {parameter} , &#39;-&gt;&#39; , term
     (* application *)
     | application term
     (* let expression *)
     | &#39;let&#39; , {let definition} , &#39;in&#39; , term
     (* successor of a natural number *)
     | &#39;succ&#39; , term
     (* natural number eliminator *)
     | &#39;rec&#39; , term , nat scrutinee type? , &#39;return&#39; , nat motive , zero branch , succ branch , &#39;end&#39;;
     (* propositional equality type *)
     | application term , &#39;=&#39; , &#39;&lt;&#39; , type , &#39;&gt;&#39; , application term
     (* reflexivity for propositional equality *)
     | &#39;refl&#39; , atomic type , atomic term
     (* propositional equality eliminator *)
     | &#39;rec&#39; , term , equality scrutinee type , &#39;return&#39; , equality motive , refl branch , &#39;end&#39;;

application term = {atomic term};

atomic type = atomic term;
            (* universe of level n *)
atomic term = &#39;Type&#39;, &#39;@&#39; , nat
            (* natural number type *)
            | &#39;Nat&#39;
            (* natural number zero *)
            | &#39;zero&#39;
            (* a shorthand for succ (succ (... (succ zero))) *)
            | nat
            (* variable *)
            | id
            (* parenthesized term *)
            | &#39;(&#39; , term , &#39;)&#39;;

parameter = &#39;(&#39; , id , &#39;:&#39; , type , &#39;)&#39;;

let definition = &#39;(&#39; , parameter , &#39;:=&#39; , term , &#39;)&#39;;

nat scrutinee type = &#39;as&#39; , &#39;nat&#39;;

(* This describes the return type of the nat eliminator
   when id is bound to the scrutinee *)
nat motive = id , &#39;.&#39; , type;

zero branch = &#39;|&#39;, &#39;zero&#39; , &#39;=&gt;&#39; , term;

(* the first id is predecessor
   and the second id is the result of the recursive call *)
succ branch = &#39;|&#39;, &#39;succ&#39; , id , id , &#39;=&gt;&#39; , term;

equality scrutinee type = &#39;as&#39; , &#39;(&#39; , application term , &#39;=&#39; , &#39;&lt;&#39; , type , &#39;&gt;&#39; , application term , &#39;)&#39;;

(* This describes the return type of the equality eliminator
   when the first id is bound to the LHS of the type of the scrutinee;
   the second id is bound to the RHS of the type of the scrutinee;
   and the third id is bound to the scrutinee *)
equality motive = id , id , id , &#39;.&#39; , type;

(* the id is bound to the LHS, which is identical to RHS *)
refl branch = &#39;|&#39;, &#39;refl&#39; , id , &#39;=&gt;&#39; , term;

id = ? sequence of upper- or lower-case ASCII alphabet characters ?;
nat = ? natural number ?;</code></pre>
<p>Here, we omit spaces between tokens. Note that the current let
expression does not support delta reduction.</p>
<h2 id="branches">Branches</h2>
<p>The Github repo includes the following special branches:</p>
<ol type="1">
<li><code>main</code>: the main branch that is used to generate this
homepage and Coqdoc;</li>
<li><code>ext/*</code>: branches in this pattern are variations of
<code>main</code> that implements various extensions. They are often
used to implement extensions that require non-trivial workload and are
aimed to be merged to <code>main</code> eventually;</li>
<li><code>icfp25</code>: the branch containing artifact for the ICFP'25
publication<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>;</li>
<li><code>gh-pages</code>: the branch to host the homepage.</li>
</ol>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Junyoung Jang, Antoine Gaulin, Jason
Z.S. Hu, and Brigitte Pientka. 2025. McTT: A Verified Kernel for a Proof
Assistant. <em>Proc. ACM Program. Lang.</em>, ICFP (2025), <a
href="https://doi.org/10.1145/3747511">https://doi.org/10.1145/3747511</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
